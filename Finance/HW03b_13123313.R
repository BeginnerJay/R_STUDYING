rm(list=ls())
#f (x) = k 풀기: x n+1 = x n - [f(x n )-k]/f'(x n ) 
# 문제
f <- function(x) 3*x^2 - 2*x - 1 # 목적함수 
k <- 0 #목적값 

#알고리즘 수행을 위한 사전 세팅 (초기값이 2인 경우)
f1 <- function(x) 6*x - 2 # 목적함수의 1계 도함수
tol <- 1e-10 # 허용오차 
x0 <- 2 # 초기값

# 알고리즘 수행 
x <- x0 # 초기화 
iter <- 0
repeat { #repeat문을 사용 -> f(X)-k의 절대값이 허용오차보다 작아지면 반복문을 break 해라.
  if(abs(f(x)-k)<tol) break
  x <- x - (f(x)-k)/f1(x) # 근데 그 x는 f(x)-k에 f(x)룰 나눈 값이다.
  iter <- iter + 1 # 몇 번 반복했는지도 나타내자.
}
x; x^2; iter # x는 1.00000000000224, iter는 5

# 알고리즘 수행을 위한 사전 세팅(초기값이 -3인 경우)
f1 <- function(x) 6*x - 2 # 목적함수의 1계 도함수
tol <- 1e-10 # 허용오차 
x0 <- -3 # 초기값

# 알고리즘 수행
x <- x0 # 초기화 
iter <- 0
while(abs(f(x)-k)>tol) { # f(X)-k의 절대값이 허용오차보다 클 때까지는 반복문을 계속 돌려라.
  x <- x - (f(x)-k)/f1(x) # 근데 그 x는 f(x)-k에 f(x)룰 나눈 값이다.
  iter <- iter + 1 # 몇 번 반복했는지도 나타내자.
}
x; x^2; iter # x는 -0.333333333340496, iter은 6

# f(x)=0이 되는 값은 x = 1 or x = -(1/3)인데, Newton-Rapfson 방법으로 각각의 근사치를 찾아내었다.
# 초기 값의 위치에 따라 찾을 수 있는 해가 달라진다는 것을 알게 되었다.